<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184 Summer 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names (with no order): Xiangru Huang (3042029019), Yanshi Liang (3041912864)</div>

		<br>

		Link to webpage: (TODO) <a href="https://github.com/cal-cs184/hw-webpages-su25-Echoooggu/blob/main/hw1/index.html">Link to webpage</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://github.com/cal-cs184/hw-rasterizer-fishros">Link to Github repository</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework.
			Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.




		<h2>Task 1: Drawing Single-Color Triangles</h2>

			<p><b>(1) How to rasterize?</b><br>
				- Given the coordinates of the three vertices of the triangle as input.<br>
				- Get the bounding box of the triangle by getting the minimum and maximum x, y coordinates of the three vertices.<br>
				- For each pixel within the bounding box, decide whether their centers are within or on the edge of the triangle by using the <code>inside()</code> function.<br>
				<b>The <code>inside</code> function:</b>
				- Bool. Decide whether a target pixel center is within the triangle<br>
				- Given coordinates of the three vertices of the triangle, we fix one of them,
				then calculate the cross product of each edge and the line between the fixed vertex and the target pixel center.<br>
				- Return true if the target point is on the same side of each edge of the triangle (i.e. the three cross products are of the same sign).
			</p>

			<p><b>(2) Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</b><br>
				- We check every pixel center within the bounding box once, by using the point-in-triangle test (i.e. the <code>inside()</code> functions).
				Then fill the pixel with color only if the pixel is within or on the edge of the triangle.<br>
				- No pixel center outside the bounding box is checked so that I save time and computation.
			</p>

			<div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
				<figure>
					<img src="Task1_test4.png" alt="Task 1 result" style="width:300px">
					<figcaption>Task1 test4</figcaption>
				</figure>
				<figure>
					<img src="Task1_with_inspector.png" style="width: 300px;">
					<figcaption>Task1 test4 with inspector.png</figcaption>
				</figure>
			</div>




		<h2>Task 2: Antialiasing by Supersampling</h2>
			<p><b>Supersampling algorithm:</b></p>
			<ol>
				<li>Divide each pixel into a grid of subpixels</li>
				<li>Rasterization: loop through the subpixels and compute their center’s location; then check whether they lie inside the triangle using the 'inside' function; then store the color values of the pixels that are inside the triangle in the 'sample_buffer'</li>
				<li>Resolve to framebuffer: after all the primitives are rasterized into the sample buffer, use <code>resolve_to_framebuffer()</code> to compute the final pixel color. For each pixel, average its subpixel values and write the result into the final framebuffer ('rgb_framebuffer_target').</li>
			</ol>

			<p><b>Data Structures used:</b></p>
			<ol>
				<li>std::vector&lt;Color&gt;: <br><code>sample_buffer()</code> stores supersampled color values for all pixels<br>size: width * height * sample_rate</li>
				<li>unsigned char: <br><code>rgb_framebuffer_target()</code> is the final framebuffer to be displayed on screen</li>
			</ol>

			<p><b>Modifications:</b></p>

			<ol>
				<li><p><b><code>set_sample_rate()</code> &amp; <code>set_framebuffer_target()</code>:</b><br></p>
					Originally, we only stored the color values of each pixel center in the sample_buffer.
					Now, we resize sample_buffer to store all color values of all pixels, including subpixels.
				</li>
				<li><p><b><code>rasterize_triangle()</code>:</b><br></p>
					Originally, we only stored the color values of each pixel center in the sample_buffer.
					Now, we resize sample_buffer to store all color values of all pixels, including subpixels.
				</li>
				<li><p><b><code>resolve_to_framebuffer()</code>:</b><br></p>
					After we resized the sample_buffer to contain color values of all pixels,
					we averaged the color values of each sample_rate times sample_rate grid.
					The, the results are written into reb_gramebuffer_target, which is ultimately displayed.
				</li>
				<li><p><b><code>fill_pixel()</code>:</b><br></p>
					Since lines and points are not supersampled,
					we modified this function to write the same color to all sub-pixels within a pixel when drawing lines and points.
				</li>
			</ol>

			<div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
				<figure>
					<img src="Task2_test4_1.png" width="250px">
					<figcaption>Task2_test4 with sample rate to be 1</figcaption>
				</figure>
				<figure>
					<img src="Task2_test4_4.png" width="250px">
					<figcaption>Task2_test4 with sample rate to be 4</figcaption>
				</figure>
				<figure>
					<img src="Task2_test4_16.png" width="250px">
					<figcaption>Task2_test4 with sample rate to be 16</figcaption>
				</figure>
			</div>

			<p><b>Why the results above are observed? <br>
				-> How does supersampling antialias our triangles? Why is supersampling useful?</b><br>
				Supersampling means that we sample each pixel multiple times instead of only once as we did without supersampling.
				We also average the results of sub-pixels within the pixel grid.<br>
				As a result, the pixel’s color does not only depend on its center or any single point within it,
				Instead, it depends on several samples, which softens the harsh transition between filled and empty pixels, producing smoother triangle edges without jaggedness.<br>
				For example, the final color of a pixel partially covered by the triangle is an average between triangle color and the background,
				and is neither the triangle color nor the background color anymore.
				This explains the results, where there seems to be more 'blurred' pixels as the sample rate increases.</p>




			<h2>Task 3: Transforms</h2>
			<p><b>Idea: a dancing Christmas tree</b><br>

			<p><b>Modifications in transform.cpp:</b><br>
			<section>
				<p style="font-size: 16px; max-width: 800px;">
					We implemented affine transformations (rotation,
					translation, and scaling) by using 3×3 matrices in homogeneous coordinates,
					where a 2D point (x, y) is transformed to a 3D vector (x, y, 1).
					This unified representation allows for combining multiple transformations efficiently in the 2D rendering pipeline.
				</p>

				<div style="display: flex; justify-content: space-around; align-items: flex-start; margin-top: 30px;">
					<div style="text-align: center;">
						<h2 style="font-size: 18px;">Rotation</h2>
						<table style="border-collapse: collapse; margin: 0 auto;">
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">cosθ</td><td style="border: 1px solid #333; padding: 10px 15px;">-sinθ</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">sinθ</td><td style="border: 1px solid #333; padding: 10px 15px;">cosθ</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">1</td></tr>
						</table>
					</div>

					<div style="text-align: center;">
						<h2 style="font-size: 18px;">Translation</h2>
						<table style="border-collapse: collapse; margin: 0 auto;">
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">1</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">dx</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">1</td><td style="border: 1px solid #333; padding: 10px 15px;">dy</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">1</td></tr>
						</table>
					</div>

					<div style="text-align: center;">
						<h2 style="font-size: 18px;">Scaling</h2>
						<table style="border-collapse: collapse; margin: 0 auto;">
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">sx</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">sy</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td></tr>
							<tr><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">0</td><td style="border: 1px solid #333; padding: 10px 15px;">1</td></tr>
						</table>
					</div>
				</div>
			</section>

			<p><b>Modifications in robot.svg:</b><br>
			<ol>
				<li><b>Head</b>
					<ul>
						<li>Deleted a polygon</li>
						<li>Color: changed the original red to Christmas red <code>#C8102E</code> by adjusting the code for <code>fill</code></li>
						<li>Adjusted the three vertices of the triangle by modifying the <code>points</code> attribute</li>
					</ul>
				</li>

				<li><b>Right hand</b>
					<ul>
						<li>Rotated the two polygons together by 45 degrees counterclockwise</li>
						<li>Color: changed the original red to Christmas green <code>#007A33</code> by adjusting the code for <code>fill</code></li>
					</ul>
				</li>

				<li><b>Right leg</b>
					<ul>
						<li>Rotated the two polygons together by 45 degrees clockwise</li>
						<li>Rotated the lower polygon by 90 degrees counterclockwise</li>
						<li>Color: changed the original red to brown <code>#8B4513</code> by adjusting the code for <code>fill</code></li>
					</ul>
				</li>

				<li><b>Torso</b>
					<ul>
						<li>Adjusted two vertices by modifying the <code>points</code> so that the torso looks like a tree trunk</li>
						<li>Color: changed the original red to Christmas green <code>#007A33</code> by adjusting the code for <code>fill</code></li>
					</ul>
				</li>

				<li><b>Left leg</b>
					<ul>
						<li>Color: changed the original red to brown <code>#8B4513</code> by adjusting the code for <code>fill</code></li>
					</ul>
				</li>

				<li><b>Left hand</b>
					<ul>
						<li>Color: changed the original red to Christmas green <code>#007A33</code> by adjusting the code for <code>fill</code></li>
					</ul>
				</li>
			</ol>

			<figure>
				<img src="Task3.png" alt="a Christmas version cubeman" style="width: 300px;">
				<figcaption>a Christmas version cubeman</figcaption>
			</figure>


		<h2>Task 4: Barycentric coordinates</h2>

			<p>
				Barycentric coordinates are a way to represent any point inside a triangle as a weighted average of the color values of its three vertices.
				If we have a triangle with vertices A, B, and C, and an arbitrary point P inside it, then P can be written as:
			</p>

			<p style="text-align: center; font-size: 18px;">
				<strong>P = αA + βB + γC</strong>
			</p>

			<p>Where:</p>
			<ul>
				<li><strong>α + β + γ = 1</strong></li>
				<li><strong>α, β, γ ≥ 0</strong> if P is inside the triangle</li>
			</ul>

			<p>
				Each of the weights α, β, γ describes how "close" the point is to one of the triangle’s corners.
				For example, if α is close to 1, the point P is close to vertex A.
			</p>

			<p>
				In the image below (from Google), we have a triangle with three vertices A, B, and C.
				Each vertex has weights (like 1kg bags) "attached" to it, simulating gravitational pull.
				These weights represent the influence each vertex has over an arbitrary point P.
			</p>

			<figure style="text-align: center;">
				<img src="barycentric_coordinates_visual_aid.jpg" alt="Barycentric Coordinates Example" width="300">
				<figcaption>barycentric coordinates interpolation visual aid</figcaption>
			</figure>

				<p>
					Algorithms:
				</p>

				<ol>
					<li>Get the bounding box of the triangle to limit the sampling region.</li>
					<li>For each pixel within the bounding box, loop through all subpixel sample positions.</li>
					<li>Calculate barycentric coordinates \( \alpha, \beta, \gamma \) for each sample using the formulas below, which are mentioned in lecture.
					<li>Store the interpolated color in the sample buffer.

				</li>
				</ol>

				<!-- Here, the MathJax for the formulas is also generated by chatGPT-->
				<p>
					\[
					\alpha = \frac{-(x - x_B)(y_C - y_B) + (y - y_B)(x_C - x_B)}{-(x_A - x_B)(y_C - y_B) + (y_A - y_B)(x_C - x_B)}
					\]
					\[
					\beta = \frac{-(x - x_C)(y_A - y_C) + (y - y_C)(x_A - x_C)}{-(x_B - x_C)(y_A - y_C) + (y_B - y_C)(x_A - x_C)}
					\]
					\[
					\gamma = 1 - \alpha - \beta
					\]
				</p>

			<p>Below is our rendered test7.svg with sample rate set to 1:</p>

			<figure style="text-align: center;">
				<img src="Task4_test7_1.png" alt="Task4 result" width="300">
				<figcaption>Task4 result with sample rate set to 1</figcaption>
			</figure>



		<h2>Task 5: "Pixel sampling" for texture mapping</h2>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>

		</div>
	</body>
</html>
